```markdown
# Лабораторні роботи

## Лабораторна 1. Про поле де робот садить гарбузи

Зеник подарував Марічці ділянку городу розміром n на m, поділену на клітинки розміром 1 на 1 метр. У кожній клітинці Марічка посадила гарбузи, щоб дарувати їх залицальникам. Марічка почала садити гарбузи починаючи із верхньої лівої, і при досягненні правої межі — розверталась і рухалась справа наліво, як вказано в прикладі для m x n, де m — кількість рядків, а n — кількість стовпців:

```
1  2  3  4
8  7  6  5
9  10 11 12
16 15 14 13
```

Для садіння Марічка вирішила використати робота-садівника, який садить в кожну клітинку задану кількість зернят, які слід вказати як одномірний масив m x n. Якщо Марічка хоче посадити таку кількість гарбузів:

```
1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16
```

Тоді роботу необхідно подати на вхід таку послідовність (маршрут робота не незмінним):

```
1  2  3  4
8  7  6  5
9  10 11 12
16 15 14 13
```

Реалізуйте алгоритм, який отримає на вхід масив розміром m та n, в кожній клітинці якого знаходиться бажана кількість гарбузів та поверне одномірний масив, скільки зернин має висаджувати робот при руху згідно маршруту, вказаного в цій задачі (маршрут є незмінним).

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest`. Ваші тести мають перевірити роботу алгоритму при значеннях m == n == 5, m = 2, n = 4, n = 1, m = 6.

---

## Лабораторна 2. Про максимальну кількість хом'яків

Зоомагазин займається продажем хом’ячків. Це мирні домашні істоти, проте, як виявилося, вони мають цікаву харчову поведінку. Для того, щоб прогодувати хом’ячка, який живе наодинці, потрібно H пакетів корму на день. Однак, якщо кілька хом’ячків живуть разом, у них прокидається жадібність. У такому випадку кожен хом’ячок з’їдає додатково G пакетів корму в день за кожного сусіда. Денна норма H та жадібність G є індивідуальними для кожного хом’ячка. Всього в магазині є C хом’ячків. Ви бажаєте придбати якомога більше, проте у вас є всього S пакетів їжі на день. Визначте максимальну кількість хом’ячків, яку ви можете прогодувати.

Реалізуйте функцію, яка поверне число - максимальне число хом’ячків, яких можна прогодувати за день.

### Вхідні параметри функції:

- S — ваш денний запас їжі. 0 ≤ S ≤ 10⁹
- C — загальна кількість хом’ячків, яка є в продажу, 1 ≤ C ≤ 10⁵
- Матриця `hamsters`, яка містить C рядків, перший стовпчик якої містить денну норму корму, другий - рівень жадібності кожного хом’ячка. Денна норма є цілими додатніми числами і гарантовано меншими за 10⁹.

### Приклади:

1. Приклад 1
    ```
    S = 7 
    C = 3 
    hamsters = [[1, 2], [2, 2], [3, 1]]
    Результат: 2
    ```
    Пояснення: Можна взяти першого хом’ячка та будь-якого з інших двох.

2. Приклад 2
    ```
    S = 19 
    C = 4 
    hamsters = [[5, 0], [2, 2], [1, 4], [5, 1]]
    Результат: 3
    ```
    Пояснення: Третій хом’ячок надто жадібний. Можна взяти всіх інших трьох, тоді за день вони з’їдять (5 + 0 · 2) + (2 + 2 · 2) + (5 + 1 · 2) = 18 пакетів.

3. Приклад 3
    ```
    S = 2 
    C = 2 
    hamsters = [[1, 50000], [1, 60000]]
    Результат: 1
    ```
    Пояснення: Обидва хом’ячки надто жадібні, щоб їсти разом.

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище.

---

## Лабораторна 3. Пошук наступника в бінарному дереві

Для заданого бінарного дерева та конкретної вершини в цьому дереві реалізуйте функцію пошуку наступного елемента під час серединного проходу (in-order traversal). Наступник - це вузол, який має значення більше за заданий вузол і знаходиться найближче до нього при серединному обході.

Нехай у вас задане бінарне дерево такого вигляду:

```
    10
   /  \
  5   15
 / \   \
3   7  20
      /
     12
```

Для вершини зі значенням 7, наступник - це вузол зі значенням 10.

### Вхідні параметри функції:

- Корінь бінарного дерева
- Вершина, для якої потрібно знайти наступника

### Клас, який описує бінарне дерево (та будь-який вузол дерева):

```python
class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
        self.parent = parent
```

### Ваша функція має мати такий вигляд:

```python
def find_successor(tree: BinaryTree, node: BinaryTree) -> BinaryTree:
    # Реалізація функції
```

### Приклад:

```python
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```

---

## Лабораторна 4. Черга з пріоритетом на основі червоно-чорного дерева

Реалізуйте структуру даних "черга з пріоритетами" на основі червоно-чорного дерева, в якому батьківський елемент має вищий пріоритет, ніж елемент справа, або нижчий або рівний пріоритет, ніж пріоритет його лівої дитини.

### Операції, які підтримує ваша черга:
- Вставка елемента з заданим значенням та пріоритетом до черги.
- Видалення та повернення елемента з найвищим пріоритетом з черги.
- Перегляд черги без її зміни.

### Реалізація черги:
Для реалізації такої черги з пріоритетами слід використати окремий клас `Node`, де кожен елемент буде мати два поля: значення та пріоритет. При вставці елемента до черги, його потрібно розмістити у відповідному порядку з урахуванням пріоритету.

### Назва файлу реалізації
- `red_black_priority_queue.py`

---

## Лабораторна 5. Про шагового коня

Умови відсутні, оскільки Slack замилив повідомлення.

---

## Лабораторна 6. Про ігровий сервер

### Опис:
Ігровий сервер 88889 Код задачі: GAMSRV. Важливим фактором для багатокористувацької онлайн-гри є низька мережева затримка від користувача до сервера. При цьому, пристрої в Інтернеті сп

ілкуються один з одним, використовуючи мережеві маршрути, які проходять через низку проміжних вузлів-маршрутизаторів. Кожна ланка цього маршруту має власну ненульову затримку.

```
Client 1 --10ms--> Router 1 --80ms--> Router 2 --50ms--> SERVER
Client 2 --100ms--> Router 2
Client 3 --20ms--> SERVER
```

### Вузли мережі можуть виконувати одну з трьох ролей:
- Client
- Router
- Server

Server може бути лише один на всю мережу. Усі комунікації двосторонні: якщо вузол A може спілкуватися з вузлом B, вузол B може спілкуватися з вузлом A з такою ж затримкою. Якщо існує кілька шляхів від клієнта до сервера, клієнт гарантовано піде шляхом з найменшою сумарною затримкою (навіть якщо цей шлях пролягає через іншого клієнта). Усі затримки — сталі додатні числа.

### Приклад:
Для прикладу вище, затримки до клієнтів становлять:
- Client 1: 10 + 80 + 50 = 140 ms
- Client 2: 100 + 50 = 150 ms
- Client 3: 20 ms

Максимальна затримка в такому випадку є 150 ms. Однак, якщо ми поміняємо ролями вузли “Router 2” і “Server”, затримки скоротяться до 90 ms, 100 ms і 70 ms відповідно, тоді максимальна затримка буде становити 100 ms.

```
Client 1 --10ms--> Router 1 --80ms--> SERVER --50ms--> Router 2
Client 2 --100ms--> SERVER
Client 3 --20ms--> Router 2
```

### Завдання:
Ви розробляєте онлайн-гру для користувачів зi всiєї країни, i бажаєте розмістити центральний ігровий сервер таким чином, щоб максимальна затримка між сервером i кожним клієнтом була мінімальною. В якості сервера можна вибрати будь-який вузол мережі, який не є клієнтом. Маючи інформацію про топологію мережі (які вузли з’єднані з якими, i яка затримка кожного з’єднання), знайдіть таке розташування сервера, яке мінімізує найбільше значення затримки до клієнта. Виведіть це значення затримки.

### Вхідні дані:
Вхідний файл `gamsrv.in` складається з M + 2 рядків:
- Перший рядок містить N i M — кількість вузлів та з’єднань відповідно. 3 ≤ N ≤ 1000, 2 ≤ M ≤ 1000.
- Другий рядок містить перелік цілих чисел, розділених пробілом — номери вузлів, які є клієнтами. Усі вузли в мережі нумеруються від 1 до N.
- Наступні M рядків містять трійки натуральних чисел `startnode`, `endnode`, `latency` — номер початкового вузла, кінцевого вузла та затримка для кожного з’єднання. 1 ≤ latency ≤ 10⁹.

### Вихідні дані:
Вихідний файл `gamsrv.out` повинен містити одне число — мінімальне значення найбільшої затримки до клієнта (яке ми отримаємо при оптимальному розташуванні сервера).

---

## Лабораторна 7. Скінченні автомати

### Опис:
Створити функцію на мові програмування Python, яка приймає дві стрічки: "haystack" (довільний текст) та "needle" (шукана стрічка). Програма повинна знайти індекси всіх входжень стрічки "needle" в стрічці "haystack" та повернути цей індекс, використовуючи метод скінченних автоматів для пошуку підстрічки у стрічці.

### Приклад:
```python
def find_substring_indices(haystack: str, needle: str) -> List[int]:
    # Реалізація функції
```

---

## Лабораторна 8. З'єднати всі острови оптоволокном у Венеції

### Опис:
До вас звернулась мерія міста Венеції з незвичним проханням. Це місто складається з островів які розділені каналами. Кожен острів має свою унікальну локацію і з'єднаний з іншими островами мостами. Мерія міста хоче провести оптоволоконний інтернет на кожен з островів таким чином, щоб кожен острів був з'єднаний з кожним іншим безпосередньо, або через інші острови. Вам потрібно допомогти порахувати мінімальну довжину кабелів, які потрібно прокласти, щоб відстань між всіма островами була мінімальна.

### Вхідні дані:
Файл `islands.csv`, який містить матрицю суміжності, де елемент [i][j] вказує на відстань між островами i та j.

### Вихідні дані:
Мінімальна довжина підводних кабелів, які потрібно прокласти. При виборі алгоритму слід вважати, що кількість островів у місті становить N (1 ≤ N ≤ 100).

---

## Лабораторна 9. Індіана Джонс В пошуках Святого Грааля

### Опис:
Індіана Джонс і останній прямокутний обхід. Код задачі: IJONES. В пошуках Святого Грааля Індіана Джонс зiткнувся з небезпечним випробуванням. Йому потрібно пройти крізь прямокутний коридор, який складається з крихких плит (пригадайте сцену з фільму «Індіана Джонс і останній хрестовий похід»). На кожній плиті написана одна літера:

```
a a a
c a b
d e f
```

### Правила:
1. Після кожного кроку Індіана повинен опинятися правіше, ніж був перед цим.
2. Завжди можна переходити на одну плиту праворуч.
3. Крім руху на одну плиту праворуч, можна перестрибувати, проте лише на ту саму літеру.

### Завдання:
Для заданого коридору, підрахуйте, скільки всього існує способів пройти його успішно.

### Вхідні дані:
Вхідний файл `ijones.in` складається з H + 1 рядків:
- Перший рядок містить два числа W і H, розділені пробілом: W — ширина коридору, H — висота коридору, 1 ≤ W, H ≤ 2000.
- Кожен з наступних H рядків містить слово довжиною W символів, яке складається з малих латинських літер від a до z.

### Вихідні дані:
Вихідний файл `ijones.out` повинен містити одне ціле число — кількість різних шляхів для виходу з коридору.

### Приклади:
1. Приклад 1
    ```
    ijones.in
    3 3
    aaa
    cab
    def
    ```
    Результат: 5
    Пояснення: Існує 3 варіанти обходу, якщо починати з літери a, і по одному варіанту, якщо починати з літери c або d.

2. Приклад 2
    ```
    ijones.in
    10 1
    abcdefaghi
    ```
    Результат: 2

3. Приклад 3
    ```
    ijones.in
    7 6
    aaaaaaa
    aaaaaaa
    aaaaaaa
    aaaaaaa
    aaaaaaa
    aaaaaaa
    ```
    Результат: 201684
```
```
